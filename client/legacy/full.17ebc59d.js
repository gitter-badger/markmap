import './web.url.19963972.js';
import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, c as create_component, a as space, f as claim_element, g as children, j as claim_component, b as claim_space, d as detach, k as attr, l as insert, n as mount_component, m as append, o as transition_in, p as transition_out, r as destroy_component, u as onMount, E as onDestroy, v as binding_callbacks, w as bind, x as add_flush_callback } from './client.1c1d7777.js';
import { M as Markmap_1 } from './markmap.e6aed8df.js';
import { T as Toolbar_1, s as subscribeHash } from './loader.a99778ec.js';

/* src/routes/full.svelte generated by Svelte v3.31.2 */

function create_fragment(ctx) {
	let main;
	let markmap;
	let updating_el;
	let updating_mm;
	let t;
	let toolbar;
	let current;

	function markmap_el_binding(value) {
		/*markmap_el_binding*/ ctx[3].call(null, value);
	}

	function markmap_mm_binding(value) {
		/*markmap_mm_binding*/ ctx[4].call(null, value);
	}

	let markmap_props = { content: /*content*/ ctx[1] };

	if (/*svgEl*/ ctx[0] !== void 0) {
		markmap_props.el = /*svgEl*/ ctx[0];
	}

	if (/*mm*/ ctx[2] !== void 0) {
		markmap_props.mm = /*mm*/ ctx[2];
	}

	markmap = new Markmap_1({ props: markmap_props });
	binding_callbacks.push(() => bind(markmap, "el", markmap_el_binding));
	binding_callbacks.push(() => bind(markmap, "mm", markmap_mm_binding));

	toolbar = new Toolbar_1({
			props: {
				class: "absolute right-0 bottom-0 mr-2 mb-2",
				isFull: true,
				showBrand: true,
				mm: /*mm*/ ctx[2]
			}
		});

	return {
		c() {
			main = element("main");
			create_component(markmap.$$.fragment);
			t = space();
			create_component(toolbar.$$.fragment);
			this.h();
		},
		l(nodes) {
			main = claim_element(nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			claim_component(markmap.$$.fragment, main_nodes);
			t = claim_space(main_nodes);
			claim_component(toolbar.$$.fragment, main_nodes);
			main_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(main, "class", "markmap-wrapper h-screen");
		},
		m(target, anchor) {
			insert(target, main, anchor);
			mount_component(markmap, main, null);
			append(main, t);
			mount_component(toolbar, main, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const markmap_changes = {};
			if (dirty & /*content*/ 2) markmap_changes.content = /*content*/ ctx[1];

			if (!updating_el && dirty & /*svgEl*/ 1) {
				updating_el = true;
				markmap_changes.el = /*svgEl*/ ctx[0];
				add_flush_callback(() => updating_el = false);
			}

			if (!updating_mm && dirty & /*mm*/ 4) {
				updating_mm = true;
				markmap_changes.mm = /*mm*/ ctx[2];
				add_flush_callback(() => updating_mm = false);
			}

			markmap.$set(markmap_changes);
			const toolbar_changes = {};
			if (dirty & /*mm*/ 4) toolbar_changes.mm = /*mm*/ ctx[2];
			toolbar.$set(toolbar_changes);
		},
		i(local) {
			if (current) return;
			transition_in(markmap.$$.fragment, local);
			transition_in(toolbar.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(markmap.$$.fragment, local);
			transition_out(toolbar.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(main);
			destroy_component(markmap);
			destroy_component(toolbar);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let svgEl;
	let content = "";
	let mm;
	let revoke;

	onMount(async () => {
		revoke = subscribeHash(text => {
			$$invalidate(1, content = text);
		});
	});

	onDestroy(() => {
		if (revoke) {
			revoke();
			revoke = null;
		}
	});

	function markmap_el_binding(value) {
		svgEl = value;
		$$invalidate(0, svgEl);
	}

	function markmap_mm_binding(value) {
		mm = value;
		$$invalidate(2, mm);
	}

	return [svgEl, content, mm, markmap_el_binding, markmap_mm_binding];
}

class Full extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Full;
